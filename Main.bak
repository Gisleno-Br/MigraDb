#include <hmg.ch>


#include <set.ch>
#include <fileio.ch>
#include "directry.ch"



DECLARE Window fprogress

FUNCTION Main

   PRIVATE cServer := 'LocalHost'
   PRIVATE cUserDb := 'root'


   PRIVATE nPercent := 0
   PRIVATE nTotal   := 0

   SET LANGUAGE TO PORTUGUESE
   SET CODEPAGE TO PORTUGUESE


   Set( _SET_DATEFORMAT, "dd/mm/yyyy" )

   HB_SetCodePage( "PT850" )
   hb_langSelect( "PT" )



   PRIVATE cPassDb := '123321'
   PRIVATE cBanco := 'sisDb'

   PRIVATE cArqT1  := ''

   PRIVATE cArqCsv := ''




   Load Window Main

   Main.Center





   Main .BtnRun. Enabled := .F.




   Main.Activate

RETURN


FUNCTION D1Black( cJan, nP1, nTot )

   LOCAL hDc

   LOCAL nRow := 0
   LOCAL nCol := 0


   LOCAL Width  := BT_ClientAreaWidth  ( cJan )
   LOCAL Height := BT_ClientAreaHeight ( cJan )

   LOCAL nW

   LOCAL BTstruct

   DEFAULT nP1  := 0
   DEFAULT nTot := 0

   hDC    = BT_CreateDC ( cJan, BT_HDC_INVALIDCLIENTAREA, @BTstruct )



   IF nP1 > 0

      nW := Int( ( np1 / nTot ) * Width )


      BT_DrawGradientFillVertical ( hDC,  nRow,  nCol,  nW,  Height, WHITE, BLACK )

   ELSE
      BT_DrawGradientFillVertical ( hDC,  nRow,  nCol,  Width,  Height, { 192, 192, 192 }, { 192, 192, 192 } )
   END IF

   BT_DeleteDC ( BTstruct )

RETURN




FUNCTION xInit()

   HMG_ChangeWindowStyle(  fProgress.Handle, NIL, WS_BORDER, .F., .T. )
   HMG_ChangeWindowStyle(  fProgress.Handle, WS_EX_STATICEDGE, NIL, .T., .T. )


   fProgress.Height := 25

   fProgress.Show()


   BT_ClientAreaInvalidateAll( 'fProgress' )

RETURN


FUNCTION Impx()

   LOCAL oServer := GetConexao()

   msginfo( 'Conectado' )



   aTexto1 := MemoRead( "Clientes.Csv" )

   aMatriz := TextToArray( aTexto1 )


   FOR n1 := 1 TO Len( aMatriz ) - 1

      cLine := aMatriz[ n1 ]


      aZ1 := hb_ATokens(  cLine, ";" )


   NEXT



   msginfo( 'ok' )


   msgBox( "Processo completo!" )

RETURN



FUNCTION xGetRt1()

   // Local cArq :=

   LOCAL cARq1 := GetFile ( { { "Mapeamentos ", "*.TY1" } }, NIL, GetCurrentFolder() )

   LOCAL aMatriz := {}

   LOCAL n1




   IF !Empty( AllTrim( cArq1 ) )
      cArqT1 := cArq1

      Main .LblArq1. Value := cArqT1

      Main .LstMap1. DeleteAllItems()




      aMatriz := TextToArray( MemoRead(    cArqt1 ) )




      // Main.LstMap1.Item := aMatriz

      FOR n1 := 1 TO Len( aMatriz )
         IF !Empty( AllTrim(  aMatriz[ n1 ] ) )
            Main .LstMap1. AddItem(  aMatriz[ n1 ]  )
         END IF
      NEXT


      Main .LblQtCampos. Value := AllTrim( Str( Len(  aMatriz   ) ) ) + ' Campos '

      SetProperty( "Main", "LstMap1", "Enabled", .F. )

      DO Events




      Main .BtnRun. Enabled := ( Len( cArqt1 ) > 0 ) .AND. (  Len( cArqCsv ) > 0  )

   END IF

RETURN



FUNCTION xGetCSV()

   // Local cArq :=

   LOCAL cARq1 := GetFile ( { { "Arquivos CSV", "*.Csv" } }, NIL, GetCurrentFolder() )
   LOCAL aMatriz
   LOCAL aSub1 := {}


   IF !Empty( AllTrim( cArq1 ) )
      cArqCsv := cArq1

      Main .LblArqCSV. Value := cArqCsv

      aMatriz := TextToArray( MemoRead(    cArqCsv ) )

      aSub1 := hb_ATokens( aMatriz[ 1 ], ';' )



      Main .LblQtLinhas. Value := AllTrim( Transform( Len(  aMatriz   ), "999,999,999"  ) ) + ' Linhas , ' + AllTrim( Str(   Len( aSub1 )   ) ) + ' Colunas '

      DO Events

      Main .BtnRun. Enabled := ( Len( cArqt1 ) > 0 ) .AND. (  Len( cArqCsv ) > 0  )

   END IF

RETURN


FUNCTION xRode()

   // HB_SETCODPAGE("PT850")
//

   LOCAL aMap := {}
   LOCAL a1
   LOCAL cCampo
   LOCAL cTipo
   LOCAL nPos
   LOCAL c1
   LOCAL aZ1  := {}
   LOCAL cData
   LOCAL nSeq  := 0


   LOCAL zk

   LOCAL aMap1 := {}
   LOCAL aValores := {}

   IF !MsgYesNo( hb_ANSIToOEM( "Confirma Execução da Importação do CSV?" ) )
      RETURN
   END IF

   Main.CURSOR := 'Hourglass.Cur'

   fProgress.CURSOR := 'Hourglass.Cur'





   aMap := TextToArray( MemoRead(    cArqt1 ) )

   c1 := ''



   FOR n1 := 1 TO Len( aMap )

      IF !Empty( AllTrim(    aMap[ n1 ]  ) )

         a1 := hb_ATokens( aMap[ n1 ], ',' )

         cCampo := a1[ 1 ]

         nPos   := Val( a1[ 2 ] )

         cTipo  := a1[ 3 ]

         c1 += ( AllTrim( cCampo ) + "," )

         AAdd( aMap1, { nPos, cTipo, cCampo }  )

      END IF

   Next 




   cVal := ''


   aCsv := TextToArray( MemoRead(    cArqCsv  ) )



   FOR n1 := 1 TO Len( aCsv )


      IF !Empty( AllTrim(  aCsv[ n1 ] ) )

         aZ1  := hb_ATokens( aCsv[ n1 ], ';' )

         cVal := ''

         FOR zK := 1 TO Len( aMap1 )

            cTipo := aMap1[ zk ][ 2 ]

            IF At( '"', az1[ aMap1[ zk ][ 1 ]   ] ) == 0

               IF cTipo = 'D'
                  cData        := Left( AllTrim( az1[ aMap1[ zk ][ 1 ]   ] ), 4 ) + "-" + ;
                     SubStr(  AllTrim( az1[ aMap1[ zk ][ 1 ]   ] ), 5, 2  ) + "-" + ;
                     Right( AllTrim( az1[ aMap1[ zk ][ 1 ]   ] ), 2 )


                  cVal += '"'  +  cData +  '"'  +  ","

               END IF


               IF cTipo = 'N'

               END IF

               IF cTipo = 'C'
                  cVal += '"'  + AllTrim( az1[ aMap1[ zk ][ 1 ]   ] ) +  '"'  +  ","
               END IF

            ELSE
               cVal += (  '"'   +  AllTrim( xRemoveAs( az1[ aMap1[ zk ][ 1 ]   ]  ) ) +   '"'  +  "," )
            END IF

         NEXT

         AAdd( aValores, Left( cVal, Len( cVal )  )    )
         // Do Events


         nSeq++

         cSql := "Insert Into " + AllTrim(  Main .Tabela. Value ) +  "(codigo," + Left( c1, Len( c1 ) - 1 )  + ") Values (" + QuotedStr( StrZero( nSeq, 6 ) ) + "," + ;
            Left( cVal, Len( cVal ) - 1 )  + ")"

      END IF


      Main .LblAndamento. Value := "Processando : " + AllTrim( Transform(   n1, "999,999,999" ) ) + "\" + AllTrim( Transform(  Len( aCsv ), "999,999,999"   ) )

      nTotal   := Len( aCsv )
      nPerCent := n1

      BT_ClientAreaInvalidateAll( 'fProgress' )


   NEXT

   MsgInfo( 'Processo Concluido!' )



   nTotal   := 0
   nPerCent := 0


   BT_ClientAreaInvalidateAll( 'fProgress' )


   SetWindowCursor( GetFormHandle( 'Main' ), IDC_ARROW )
   SetWindowCursor( GetFormHandle( 'fProgress' ), IDC_ARROW )

RETURN


FUNCTION xRemoveAs(   cCar   )

   LOCAL cStr1 :=  AllTrim( Right( cCar, Len( cCar ) - 1 ) )
   LOCAL cStr2 := Left( cStr1, Len( cStr1 ) - 1 )

RETURN cStr2


FUNCTION GetConexao()

   LOCAL oServer
   LOCAL lRet
   LOCAL oQuery

   oServer := TMySQLServer():New( cServer, cUserDb, cPassDb )

   IF oServer:NetErr()
      MsGInfo( "Error ao Conectar SQL Server: " + QUEBRA + oServer:Error() )
      RELEASE Window ALL
      QUIT
   ENDIF

   oServer:SelectDB( cBanco )

   IF oServer:NetErr()
      MsGInfo( "Error ao Conectar Banco " + cBanco + " : " + QUEBRA + oServer:Error() )
      RELEASE Window ALL
      QUIT
   ENDIF

RETURN ( oServer )


STATIC FUNCTION TextToArray( cString )
RETURN hb_ATokens( StrTran( cString, Chr( 13 ) ), Chr( 10 ) )



FUNCTION fTiraChar( wCampo )

   // // Remover Caracteres Especiais (/,*)

   LOCAL lRet  := .T.
   LOCAL cStr1 := ''
   LOCAL i     := 1 // '

   FOR i := 1 TO Len( wCampo )
      IF SubStr( wCampo, i, 1 ) == "'" .OR. SubStr( wCampo, i, 1 ) == '"'  .OR. SubStr( wCampo, i, 1 ) == ")" .OR. SubStr( wCampo, i, 1 ) == "(" .OR. SubStr( wCampo, i, 1 ) == "*" .OR. SubStr( wCampo, i, 1 ) == "/"  .OR. SubStr( wCampo, i, 1 ) == "\"  .OR. SubStr( wCampo, i, 1 ) == '%' .OR. SubStr( wCampo, i, 1 ) == "-"

      ELSE
         cStr1 += SubStr( wCampo, i, 1 )
      ENDIF
   NEXT i

RETURN cStr1


FUNCTION QuotedStr( cVar )
RETURN '"' + cVar + '"'
